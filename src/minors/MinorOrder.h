/***************************************************************************
 *   Copyright (C) 2014 by Jan Stückrath <jan.stueckrath@uni-due.de>       *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   51 Franklin St, Fifth Floor, Boston, MA 02110, USA                    *
 ***************************************************************************/

#ifndef MINORORDER_H_
#define MINORORDER_H_

#include "../graphs/Hypergraph.h"
#include "../graphs/Mapping.h"
#include "../basic_types/Order.h"
#include "../basic_types/IDPartitionEnumerator.h"

namespace uncover {
	namespace minors {

		/**
		 * This class implements the Hypergraph Minor Ordering, as described in "Applying the Graph Minor
		 * Theorem to the Verification of Graph Transformation Systems" (Salil Joshi, Barbara König).
		 * @author Jan Stückrath
		 */
		class MinorOrder : public basic_types::Order
		{

			public:

				/**
				 * Creates a new MinorOrder object.
				 */
				MinorOrder();

				/**
				 * Destroys the current MinorOrder object.
				 */
				virtual ~MinorOrder();

				/**
				 * Checks whether the first given graph is a minor of the second.
				 * @param smaller the possible minor
				 * @param bigger the possibly larger graph
				 * @return true iff the first graph is a minor of the second
				 */
				virtual bool isLessOrEq(graphs::Hypergraph const& smaller, graphs::Hypergraph const& bigger) const override;

			private:

				/**
				 * Checks if edges of the given graph can be contracted to obtain a smaller graph. The smaller graph is
				 * implicitly given by the Mapping and Mapping::Inversion parameters.
				 * @param graphB the graph of which edge contractions are simulated
				 * @param nodeMap the map of nodes of graphB to the smaller graph
				 * @param invNodeMap the inversion of nodeMap
				 * @param preservedEdges the set of all IDs of edges of graphB which have an image in the smaller graph
				 * @param isoNodes the number of isolated nodes, the smaller graph has more than graphB (may be negative)
				 * @return true iff the smaller graph can be generated from graphB by contraction of edges
				 */
				bool checkContractions(
						graphs::Hypergraph const& graphB,
						graphs::Mapping const& nodeMap,
						graphs::Mapping::Inversion const& invNodeMap,
						unordered_set<IDType> const& preservedEdges,
						int isoNodes) const;

				/**
				 * Given a mapping of edges of graphS to edges of graphB, this method generates a Mapping of node IDs of
				 * graphB to node IDs of graphS induced by the edge map (storing it in nodeMap). Additionally all edge
				 * IDs in graphB used for this Mapping are stored in preservedEdges. If it is not possible to generate a
				 * Mapping from the given data, this function returns false.
				 * @param graphS the smaller graph
				 * @param graphB the larger graph
				 * @param edgeMapS a map where the keys are labels of edges in graphS and values are the collection of
				 * 				edge IDs of graphS with this label
				 * @param edgeMapB a map where the keys are labels of edges in graphS(!) and values are the collection of
				 * 				edge IDs of graphB with this label
				 * @param edgesToEdges a vector of pairs where the first element is a label and the second a vector
				 * 				defining that the i-th edge in edgeMapS with that label is mapped to the edgesToEdges[i]-th
				 * 				edge in edgeMapB with that label
				 * @param nodeMap the mapping of nodes to nodes, generated by this method is stored in this parameter
				 * @param preservedEdges the IDs of edges of graphB used to generate the node map are stored in this
				 * 				parameter
				 * @return true, iff it is possible to generate a node Mapping
				 */
				bool generateMapp(
						graphs::Hypergraph const& graphS,
						graphs::Hypergraph const& graphB,
						map<string, vector<IDType>> const& edgeMapS,
						map<string, vector<IDType>> const& edgeMapB,
						vector<pair<string,vector<size_t>>> const& edgesToEdges,
						graphs::Mapping& nodeMap,
						unordered_set<IDType>& preservedEdges) const;

				/**
				 * Clears the given vector and fills it with the numbers from 0 to numCount-1.
				 * @param vec the vector to be reset
				 * @param numCount the number of elements added to the vector
				 */
				void reset(vector<size_t>& vec, size_t numCount) const;

				/**
				 * Increments the given vector such that it represents the next possible mapping of edges of the smaller
				 * graph to edges of the larger graph.
				 * @param vec the vector which will be "incremented"
				 * @param posTargets a mapping of labels of the larger graph to IDs of edges with this labels
				 * @return true, iff the incrementation was possible (false if all possible incrementations have been
				 * 				 performed)
				 */
				bool inc(vector<pair<string,vector<size_t>>>& vec, map<string, vector<IDType>>& posTargets) const;

				/**
				 * Increments the given vector such that it consists of the next sequence of distinct values between 0 and
				 * tarCount-1.
				 * @param vec the vector which will be "incremented"
				 * @param tarCount the vector will only consist of (distinct) values between 0 and tarCount-1
				 * @return true, iff the incrementation was possible (false if all possible incrementations have been
				 * 				 performed)
				 */
				bool inc(vector<size_t>& vec, size_t tarCount) const;

				/**
				 * Increments the given vector ignoring the first pos indices. The enumerator at the index pos is incremented
				 * and possibly also higher indices if the enumerator has ended. Enumerators at indices before pos are
				 * reset.
				 * @param enums the vector of enumerators which will be incremented
				 * @param pos the number of indices ignored (beginning from 0)
				 * @return true, iff the incrementation was possible (false if all possible incrementations have been
				 * 				 performed)
				 */
				bool inc(vector<basic_types::IDPartitionEnumerator>& enums, size_t pos) const;

				/**
				 * Finds the occurrence of toFinde with the least index in the vector. If none could be found,
				 * vec.size() is returned.
				 * @param vec the vector to be searched
				 * @param tofind the element to be found
				 * @return the least index of the element of vec.size() if none was found
				 */
				size_t findFirst(vector<size_t> const& vec, size_t tofind) const;

				/**
				 * Checks if the given partition is finer that the partition induced by the Mapping. The partition is finer iff,
				 * whenever two elements are in the same subpartition, they have the same image under the Mapping. IDs without
				 * images under the Mapping are ignored.
				 * @param part the partition to be tested
				 * @param mapp the Mapping to be tested
				 * @return true iff the partition is finer (or equally fine)
				 */
				bool isFiner(basic_types::IDPartition const& part, graphs::Mapping const& mapp) const;

				/**
				 * Checks if the given partition is included in the inverse Mapping. A partition is included in an inverse
				 * Mapping iff, whenever two IDs have the same image under the Mapping, both IDs are in the same subpartition.
				 * @param part the partition to be tested
				 * @param mapp the inverse Mapping to be tested
				 * @return true, iff the partition is included in the inverse Mapping
				 */
				bool isIncludedIn(basic_types::IDPartition const& part, graphs::Mapping::Inversion const& mapp) const;

				/**
				 * Checks if the given partition has enough subpartitions to be mapped to isolated nodes. Such a mapping is
				 * possible if all elements of a subpartition do not have an image under the Mapping. The number of
				 * subpartitions necessary is given by num.
				 * @param part the partition to be tested
				 * @param mapp a Mapping of all nodes which are incident to edges which are mapped to the smaller graph
				 * @param num the number of isolated nodes the smaller graph has more than the larger graph (may be negative)
				 * @return true, iff enough subpartitions exist
				 */
				bool enoughIsolated(basic_types::IDPartition const& part, graphs::Mapping const& mapp, int num) const;

		};

	}
}

#endif
