/***************************************************************************
 *   Copyright (C) 2014 by Jan St端ckrath <jan.stueckrath@uni-due.de>       *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   51 Franklin St, Fifth Floor, Boston, MA 02110, USA                    *
 ***************************************************************************/

#ifndef PREPAREDGTS_H_
#define PREPAREDGTS_H_

#include "../graphs/GTS.h"
#include "RulePreparer.h"
#include "../graphs/UQRuleInstance.h"

namespace uncover {
	namespace analysis {

		/**
		 * The PreparedGTS class represents a graph transformation system that was prepared for use in the
		 * backward procedure. It is instantiated with a GTS and a RulePreparer object. The standard rules
		 * of the GTS are prepared and stored as standard rules of the PreparedGTS. For UQRules, this class
		 * provides the uqinst_iterator to iterate over all UQRuleInstances which have to be applied
		 * backwards to a given UQRule and graph.
		 * @author Jan St端ckrath
		 * @see graphs::GTS
		 * @see RulePreparer
		 */
		class PreparedGTS: public graphs::GTS {

			public:

				/**
				 * The uqinst_iterator generates UQRuleInstances for backward application. It is generated by
				 * the beginUQInstances() and endUQInstances() methods of PreparedGTS. The number of UQInstances
				 * generated depends on the number of universal quantifications of the corresponding UQRule and
				 * on the graph to which the rule should be applied backwards.
				 * @author Jan St端ckrath
				 * @see PreparedGTS
				 */
				class uqinst_iterator {

					friend class PreparedGTS;

					public:

						/**
						 * Move constructor. Generates a new iterator using the data of the given iterator. The given
						 * iterator is invalidated by this constructor and may not be used any further (except for deletion).
						 * @param old the old iterator for which the data will be copied
						 */
						uqinst_iterator(PreparedGTS::uqinst_iterator&& old);

						/**
						 * Destroys this iterator.
						 */
						~uqinst_iterator();

						/**
						 * Computes the next UQRuleInstance of the UQRule corresponding to this iterator.
						 * @return a reference to this iterator
						 */
						PreparedGTS::uqinst_iterator& operator++ ();

						/**
						 * Returns the last UQRuleInstance computed by this iterator (i.e. by the last ++ call).
						 * The returned UQRuleInstance can be used and modified freely, without affecting the this
						 * iterator. However, this iterator keeps a pointer to the UQRuleInstance and will return this
						 * pointer in any subsequent * call, as long as the iterator was not incremented again. If
						 * the iterator ended, this operator will return a null pointer.
						 * @return the last computed UQRuleInstance
						 */
						graphs::UQRuleInstance_sp operator*();

						/**
						 * Returns true, if this iterator has ended, i.e. the last UQRuleInstance was already computed and returned.
						 * @return true, if this iterator has ended
						 */
						bool hasEnded();

					private:

						/**
						 * Generates a new iterator for the given rule. This iterator will use the given RulePreparer
						 * on every generated UQRuleInstance and will generate instances up to the given bound.
						 * @param rule the rule to be used
						 * @param rulepreparer the RulePreparer to be used
						 * @param bound the bound up to which UQRuleInstances will be generated
						 */
						uqinst_iterator(graphs::UQRule_sp rule, RulePreparer_sp rulepreparer, unsigned int bound);

						/**
						 * Drops the current UQRuleInstance and computes the next one if possible. If there is no
						 * UQRuleInstance to compute, this iterator ends.
						 * @param firstTime if this parameter is true, the internal iterator will no be incremented by
						 * 				this call; this is necessary in the first call of this function after initializing the
						 * 				iterator
						 */
						void loadNextRule(bool firstTime = false);

						/**
						 * Sums up how much instantiations will be performed when using the current value of currentQuant.
						 * The sum computed by this function may not exceed the defined bound.
						 * @return how much instantiations will be performed when using the current value of currentQuant
						 */
						unsigned int sumCurrentQuant();

						/**
						 * Stores the UQRule used by this iterator.
						 */
						graphs::UQRule_sp rule;

						/**
						 * Stores the RulePreparer used by this iterator.
						 */
						RulePreparer_sp rulePreparer;

						/**
						 * Stores a count for each Quantification of the UQRule storing how often each Quantification will
						 * be used when generating the next UQRuleInstance.
						 */
						vector<unsigned int>* currentQuant;

						/**
						 * Stores the UQRuleInstances generated by preparing a last computed UQRuleInstance. These instances
						 * will be returned one after the other before computing the next UQRuleInstance.
						 */
						vector<graphs::UQRuleInstance_sp>* currentInstances;

						/**
						 * Stores the bound to which UQRuleInstances are generated.
						 */
						unsigned int bound;

				};

				/**
				 * Creates a Prepared GTS using the given GTS and RulePreparer. All rules of the given GTS are prepared
				 * and all resulting rules added to this PreparedGTS. If optimization is enabled (default), rules are
				 * only added if they are no order morphism wrt. to the order used by the RulePreparer (these rules
				 * do not produce new results during the backward search). UQRules are not prepared and just copied.
				 * @param gts the GTS of which the rules will be prepared
				 * @param rulePrep the RulePreparer used for preparation
				 * @param opt if true (default), then order morphisms will not be added to this PreparedGTS
				 */
				PreparedGTS(GTS const& gts, RulePreparer_sp rulePrep, bool opt = true);

				/**
				 * Destroys this PreparedGTS.
				 */
				virtual ~PreparedGTS();

				/**
				 * Creates and returns an iterator, iterating over all UQRuleInstances of the UQRule with the given ID,
				 * which need to be applied backward to the given graph. The number of UQRuleInstance increases
				 * exponentially with the complexity of the rule (i.e. the basis is the number of Quantifications) and
				 * the size of the graph (the exponent).
				 * @param ruleID the ID of the UQRule to be instantiated
				 * @param graph the graph to which the UQRule should be applied backwards to
				 * @return an iterator, enumerating all necessary instances of the UQRule
				 */
				PreparedGTS::uqinst_iterator beginUQInstances(IDType const& ruleID, graphs::Hypergraph const& graph);

				/**
				 * Creates a new collection which contains all original rules from which the prepared rule with the
				 * given ID could have been generated from.
				 * @param id the ID of the prepared rule
				 * @return the collection of original rules
				 */
				shared_ptr<vector<graphs::AnonRule_csp>> getOriginalRules(IDType id) const;

			protected:

				/**
				 * Creates and stores all UQRuleInstances for the given UQRule up to the given bound. The generated
				 * UQRuleInstances are stored in uqRuleInstances and indexed by uqRuleLengths.
				 * @param ruleID the ID of the UQRule to be instantiated
				 * @param bound the size up to which instances should be generated
				 */
				void createInstancesUpTo(IDType const& ruleID, size_t bound);

				/**
				 * Stores the RuleMap containing the (unprepared) rules of the original GTS.
				 */
				const RuleMap oldStdRules;

				/**
				 * Stores for every new (prepared) rule the ID of the original rules from which it was prepared. Note that a
				 * prepared rule may have multiple original rules from which it was generated, even if these rules where not
				 * isomorphic.
				 */
				map<IDType, vector<IDType>> prepFrom;

				/**
				 * Stores the RulePreparer used by this PreparedGTS.
				 */
				RulePreparer_sp rulePreparer;

				/**
				 * For each ID of a UQRule (key) this map stores all UQRuleInstances (value) generated for the
				 * corresponding UQRule.
				 */
				unordered_map<IDType, vector<graphs::UQRuleInstance_sp>> uqRuleInstances;

				/**
				 * For each ID of a UQRule (key) this map stores a vector of positions (value). The i-th value
				 * in the vector is the first position in the corresponding vector of uqRuleInstances (with the
				 * same UQRule ID) where the length of the instantiation is i.
				 */
				unordered_map<IDType, vector<size_t>> uqRuleLengths;

				/**
				 * The StdRuleMapCB is a helper class defining a CollectionCallback to a PreparedGTS standard rule map.
				 * For every rule added it also stores that it was prepared by the rule with the ID currently set in this
				 * callback.
				 * @see CollectionCallback
				 * @see PreparedGTS
				 * @author Jan St端ckrath
				 */
				class StdRuleMapCB : public basic_types::CollectionCallback<graphs::Rule_sp> {

					public:

						/**
						 * Creates a new CollectionCallback to the given PreparedGTS standard rule map.
						 * @param gts to which rules will be added by the callback
						 */
						StdRuleMapCB(PreparedGTS& gts) : gts(gts), currentRuleID(0) {};

						/**
						 * Destroys this StdRuleMapCB, not affecting the references PreparedGTS.
						 */
						virtual ~StdRuleMapCB() {}

						/**
						 * Adds the given Rule to the standard rule map of the PreparedGTS. It is also referenced
						 * as having been prepared from the rule with the ID currently stored in this callback.
						 * @param rule the rule to be added
						 */
						virtual void insert(graphs::Rule_sp rule) {
							gts.addStdRule(rule);
							gts.prepFrom[rule->getID()].push_back(currentRuleID);
						}

						/**
						 * Sets the ID of the rule which was used to generate any subsequently added (prepared) rules
						 * (until the next time this function is called).
						 */
						void setCurrentRuleID(IDType id) {
							currentRuleID = id;
						}

					private:

						/**
						 * Stores a reference to the PreparedGTS to which Rules will be added by this callback.
						 */
						PreparedGTS& gts;

						/**
						 * Stores an ID which will be set as the original rule ID from which any rules added by insert(...)
						 * were generated.
						 */
						IDType currentRuleID;

				};

		};

		/**
		 * Alias of a shared pointer to a PreparedGTS.
		 */
		typedef shared_ptr<PreparedGTS> PreparedGTS_sp;

		/**
		 * Alias of a shared pointer to a constant PreparedGTS.
		 */
		typedef shared_ptr<PreparedGTS const> PreparedGTS_csp;


	} /* namespace analysis */
} /* namespace uncover */

#endif /* PREPAREDGTS_H_ */
